# BEGIN softGlue.iocsh ----------------------------------------------------------

epicsEnvSet("PORT1", "SGIO_1")
epicsEnvSet("PORT2", "SGIO_2")
epicsEnvSet("PORT3", "SGIO_3")
epicsEnvSet("SPORT", "AXI0")
epicsEnvSet("RPORT", "AXI1")
epicsEnvSet("PREFIX", "zzz:")
epicsEnvSet("INSTANCE", "softGlue:")
epicsEnvSet("CONFIG", "SG")
epicsEnvSet("READEVENT", "10")


#var devAsynSoftGlueDebug,1
#var drvZynqDebug,5
################################################################################
#    Initialize the FPGA
#-----------------------
#    Write content to the FPGA.    This command will fail if the FPGA already
#    has content loaded, as it will after a soft reboot.  To load new FPGA
#    content, you must power cycle the ioc.
#
#    initIP_EP200_FPGA(ushort carrier, ushort slot, char *filename)
#    carrier:  IP-carrier number (numbering begins at 0)
#    slot:     IP-slot number (numbering begins at 0)
#    filename: Name of the FPGA-content hex file to load into the FPGA.
#

#initZynqIP("softGlue_FPGAContent_7010.bin")
#system("loadFPGA_3_IO.sh")
system("cat $(SOFTGLUEZYNQ)/softGlueApp/Db/softGlue_FPGAContent_7010.bin >/dev/xdevcfg")
#system("cat $(SOFTGLUEZYNQ)/softGlueApp/Db/softGlue_FPGAContent_7020.bin >/dev/xdevcf")

#-------------------------------------------------------------------------------
#int initZynqIO(const char *portName, 
#	int msecPoll, int dataDir, int AXI_Address, int interruptVector,
#	int risingMask, int fallingMask) {
#    portName: Name of asyn port for component at sopcOffset
#    msecPoll:        Time interval between driver polls of field I/O bits
#    dataDir:         Data direction for I/O bits, explained below.
#    AXI_Address:     AXI_Address.
#    interruptVector: Must agree with the FPGA content loaded (0x90, 0x91,
#                     0x92 for softGlue 2.1 and higher; 0x80, 0x81, 0x82 for
#                     softGlue 2.0 and lower).
#    risingMask:      16-bit mask: if a bit is 1, the corresponding I/O bit will
#                     generate an interrupt when its value goes from 0 to 1.
#                     Bit 0 corresponds to field I/O pin 1, bit 1 to pin 2, etc.
#    fallingMask:     Similar to risingMask, but for 1-to-0 transitions.
#
#                     Note that the user can overwrite risingMask and
#                     fallingMask at run time, with menu selections, and
#                     probably has those selections autosaved.
#    dataDir is yet to be determined.
#!initZynqIO("$(PORT1)",1000000,0x101,0x800000,0x90,0x00,0x00)
#!initZynqIO("$(PORT2)",1000000,0x101,0x800010,0x91,0x00,0x00)
#!initZynqIO("$(PORT3)",1000000,0x101,0x800020,0x92,0x00,0x00)

################################################################################
#    Initialize softGlue signal-name support
#-------------------------------------------
#    All instances of a single-register component are initialized with a single
#    call, as follows:
#
#initZynqSingleRegisterPort(const char *portName, int AXI_BaseAddress)
#
# For example:
# initZynqSingleRegisterPort("$(SPORT)", 0x43C00000)
initZynqSingleRegisterPort("$(SPORT)", 0x43C00000)
initZynqSingleRegisterPort("$(RPORT)", 0x43C20000)


################################################################################
#    Load databases
#------------------
#    Load a single database that all database fragments supporting
#    single-register components can use to show which signals are connected
#    together.  This database is not needed for the functioning of the
#    components, it's purely for the user interface.
dbLoadRecords("$(SOFTGLUEZYNQ)/db/softGlue_SignalShow.db","P=$(PREFIX),H=$(INSTANCE),PORT=$(SPORT),READEVENT=$(READEVENT)")

#    Load a set of database fragments for each single-register component.
# This database contains the records for standard softGlue, and must be loaded
# for all .hex files above 
dbLoadRecords("$(SOFTGLUEZYNQ)/db/softGlue_FPGAContent.db", "P=$(PREFIX),H=$(INSTANCE),PORT=$(SPORT),READEVENT=$(READEVENT)")
dbLoadRecords("$(SOFTGLUEZYNQ)/db/softGlue_FPGARegisters.db", "P=$(PREFIX),H=$(INSTANCE),PORT=$(RPORT),READEVENT=$(READEVENT)")


#    Interrupt support.
#    ('epicsEnvSet' is used to fit the command into the vxWorks command line space.)
#epicsEnvSet("SFDB", "$(SOFTGLUEZYNQ)/db/softGlue_FPGAInt.db")
#dbLoadRecords("$(SFDB)","P=$(PREFIX),H=$(INSTANCE),PORT1=$(PORT1),PORT2=$(PORT2),PORT3=$(PORT3),FIFO=10")
#dbLoadRecords("$(SOFTGLUEZYNQ)/db/softGlue_FPGAInt.db","P=$(PREFIX),H=$(INSTANCE),PORT1=$(PORT1),PORT2=$(PORT2),PORT3=$(PORT3),FIFO=10")

#    Some stuff just for convenience: software clock and pulse generators, and
#    a couple of busy records.
dbLoadRecords("$(SOFTGLUEZYNQ)/db/softGlue_convenience.db", "P=$(PREFIX),H=$(INSTANCE)")

# Menu of softGlue circuits
# configMenu example.  See create_manual_set() command after iocInit.
dbLoadRecords("$(AUTOSAVE)/asApp/Db/configMenu.db","P=$(PREFIX),CONFIG=$(CONFIG)")
# Note that the request file MUST be named $(CONFIG)Menu.req.  If the macro
# CONFIGMENU is defined with any value, backup (".savB") and sequence files
# (".savN") will not be written.  We don't want these for configMenu.
doAfterIocInit("create_manual_set('$(CONFIG)Menu.req','P=$(PREFIX),CONFIG=$(CONFIG),H=$(INSTANCE),CONFIGMENU=1')")

# Register included example of a custom softGlue interrupt-service routine.
# This is for interrupts that occur too closely spaced in time for softGlue's
# normal interrupt service (an output link to an EPICS record) to handle.
# Note that this command must be issued after iocInit.
#doAfterIocInit("sampleCustomInterruptPrepare($(IPCARRIER), $(IPSLOT), 0x800010, 0x1)")

# debug:
dbLoadRecords("$(ASYN)/db/asynRecord.db","P=zzz:,R=asynSoftGlue,PORT=$(SPORT),ADDR=0,OMAX=0,IMAX=0")
dbLoadRecords("$(ASYN)/db/asynRecord.db","P=zzz:,R=asynSoftGlueReg,PORT=$(RPORT),ADDR=0,OMAX=0,IMAX=0")
# END softGlue.cmd ------------------------------------------------------------
